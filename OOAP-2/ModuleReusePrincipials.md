# Принципы повторного использования модуля

Как в Javascript(Typescript) можно организовать и экспортировать/импортровать модуль

Если в среде node.js

```typescript
// файл user.js
const sayHello = () => {};
const go = () => {};

module.exports = {
  sayHello,
  go,
};

// Затем в другом файле
const user = require('./user.js') // получили модуль User
```

При разработке для веба
```typescript
// файл user.js
export const sayHello = () => {};
export const go = () => {};

// в другом файле

import * as User from './user.js'
```

Таким образом модули в экосистеме JS удается выполнить пункты 2, 3 и 5.

2 - Новый модуль может объединять несколько функций, которые активно обращаются друг к другу; (Используя синтаксис import/export)

3 - Новый модуль может входить в семейство модулей, ориентированных на решение некоторой общей задачи, которую не удаётся решить с помощью одного модуля; (Можем импортировать один модуль в другой)

5 - Новый модуль может интегрировать общее поведение нескольких модулей, которые различаются лишь деталями. (В один модуль можем импортировать сколько угодно других модулей import/export. Главное, что бы не было циклических импортов.)

1 и 4 выполнить не получается 

1 - Новый модуль может задавать некоторый базовый тип, который потенциально должен допускать параметризацию другими типами (обобщённые типы, типы-генерики);

Даже если мы напишем так:
```typescript
import * as User from './user.js'

type UserType = typeof User // тут мы не получим явный тип, которым можно было бы пользоваться.
```

4 -  Новый модуль может предлагать конкретную реализацию родительского модуля, которая должна выбираться динамически (полиморфно) - например, реализация обобщённого типа для конкретного типа-параметра;

Т.к. модули не имеют типа, то и обобщенный тип мы предложить не можем.

